//
//  FCGenstrings.m
//  InterfaceGenstrings
//
//  Created by Almer Lucke on 9/9/15.
//  Copyright (c) 2015 AliensAreAmongUs. All rights reserved.
//


#import "FCGenstrings.h"


@interface FCLocalizedStringEntry : NSObject

@property (nonatomic, copy) NSString *entryKey;

@property (nonatomic, copy) NSString *entryValue;

@property (nonatomic, copy) NSString *entryComment;

@end


@implementation FCLocalizedStringEntry

@end



@implementation FCGenstrings

#pragma mark - Source Filed (.m)

+ (NSArray *)strippedStringsFromSourceString:(NSString *)sourceString
{
    NSRange searchedRange = NSMakeRange(0, [sourceString length]);
    
    // regex for c strings including escape characters
    NSString *pattern = @"\"(\\\\.|[^\"])*\"";
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:nil];
    NSMutableArray *strippedStrings = [NSMutableArray array];
    
    if (regex) {
        NSArray *matches = [regex matchesInString:sourceString options:0 range:searchedRange];
        NSCharacterSet *trimQuotesCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@"\""];
        
        for (NSTextCheckingResult *match in matches) {
            NSString* matchText = [sourceString substringWithRange:[match range]];
            
            // trim " characters from begin and end
            [strippedStrings addObject:[matchText stringByTrimmingCharactersInSet:trimQuotesCharacterSet]];
        }
    }
    
    return [strippedStrings copy];
}

+ (NSArray *)localizedStringsForSourceFile:(NSString *)sourceFilePath
{
    // use filename as comment if comment is nil
    NSString *fileName = [sourceFilePath lastPathComponent];
    
    NSString *source = [NSString stringWithContentsOfFile:sourceFilePath encoding:NSUTF8StringEncoding error:nil];
    NSMutableArray *allStringPairs = [NSMutableArray array];
    
    if (source) {
        // first get all regex matches for all possible variants for NSLocalizedString(@"key", @"value")
        NSRange searchedRange = NSMakeRange(0, [source length]);
        NSString *pattern = @"NSLocalizedString\\s*\\(\\s*@\"(\\\\.|[^\"])*\"\\s*,\\s*(nil|@\"(\\\\.|[^\"])*\")\\s*\\)";
        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:nil];
        NSArray *matches = [regex matchesInString:source options:0 range:searchedRange];
        
        for (NSTextCheckingResult *match in matches) {
            // get string from matched range and strip it into key and optional comment pairs
            NSString* matchText = [source substringWithRange:[match range]];
            NSArray *pair = [self strippedStringsFromSourceString:matchText];
            
            if (pair.count == 1) {
                // use filename as comment if comment is nil
                pair = @[pair[0], fileName];
            }
            
            [allStringPairs addObject:pair];
        }
    }
    
    return [allStringPairs copy];
}


#pragma mark - Interface Files (.storyboard, .xib)

+ (NSString *)strippedStringFromInterfaceString:(NSString *)interfaceString
{
    NSRange searchedRange = NSMakeRange(0, [interfaceString length]);
    
    // regex for c strings including escape characters
    NSString *pattern = @"\"(\\\\.|[^\"])*\"";
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:nil];
    
    if (regex) {
        // we expect the interfaceString (generated by xcode in xib or storyboard file) to be like
        // "<userDefinedRuntimeAttribute type=\"string\" keyPath=\"localizableInterfaceElementKey\" value=\"some value\"/>
        // so find all c strings and the last one should be the one we are looking for
        NSArray *matches = [regex matchesInString:interfaceString options:0 range:searchedRange];
        
        if (matches.count == 3) {
            NSTextCheckingResult *match = matches[2];
            NSString* matchText = [interfaceString substringWithRange:[match range]];
            NSCharacterSet *trimQuotesCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@"\""];
            
            // trim " characters from begin and end
            return [matchText stringByTrimmingCharactersInSet:trimQuotesCharacterSet];
        }
    }
    
    return nil;
}

+ (NSArray *)localizedStringsForInterfaceFile:(NSString *)interfaceFilePath
{
    NSString *fileName = [interfaceFilePath lastPathComponent];
    NSError *error = nil;
    NSString *source = [NSString stringWithContentsOfFile:interfaceFilePath encoding:NSUTF8StringEncoding error:&error];
    NSMutableArray *allStringPairs = [NSMutableArray array];
    
    if (source) {
        NSRange searchedRange = NSMakeRange(0, [source length]);
        
        // match xcode generated pattern generated for our user defined keyPath localizableInterfaceElementKey
        NSString *pattern = @"<userDefinedRuntimeAttribute type=\"string\" keyPath=\"localizableInterfaceElementKey\" value=\"(\\\\.|[^\"])*\"\\/>";
        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&error];
        
        if (regex) {
            NSArray *matches = [regex matchesInString:source options:0 range:searchedRange];
        
            for (NSTextCheckingResult *match in matches) {
                NSString* matchText = [source substringWithRange:[match range]];
                NSArray *pair = @[[self strippedStringFromInterfaceString:matchText], fileName];
                
                [allStringPairs addObject:pair];
            }
        }
    }
    
    return [allStringPairs copy];
}


#pragma mark - Scan Localized Strings For Directory

+ (NSDictionary *)localizedStringsForDirectory:(NSString *)directory
{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *subPaths = [fileManager subpathsOfDirectoryAtPath:directory error:nil];
    NSMutableDictionary *entries = [NSMutableDictionary dictionary];
    
    for (NSString *path in subPaths) {
        NSString *extension = [path pathExtension];
        NSString *fullPath = [directory stringByAppendingPathComponent:path];
        NSArray *pairs = nil;
        
        if ([extension isEqualToString:@"m"]) {
            // good old fashioned NSLocalizedString
            pairs = [self localizedStringsForSourceFile:fullPath];
        } else if ([extension isEqualToString:@"storyboard"] || [extension isEqualToString:@"xib"]) {
            // storyboard and xib use the same pattern
            pairs = [self localizedStringsForInterfaceFile:fullPath];
        }
        
        for (NSArray *pair in pairs) {
            FCLocalizedStringEntry *entry = [[FCLocalizedStringEntry alloc] init];
            entry.entryKey = pair[0];
            entry.entryValue = @"";
            entry.entryComment = pair[1];
            
            entries[entry.entryKey] = entry;
        }
    }
    
    return [entries copy];
}


#pragma mark - Existing Localizable.strings

+ (NSArray *)localizableStringsFilesForDirectory:(NSString *)directory
{
    // get paths for all localizable string files in root directory (recursive)
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *subPaths = [fileManager subpathsOfDirectoryAtPath:directory error:nil];
    NSMutableArray *localizableStringsFiles = [NSMutableArray array];
    
    for (NSString *path in subPaths) {
        NSString *fullPath = [directory stringByAppendingPathComponent:path];
        NSString *lastPathComponent = [path lastPathComponent];
        
        if ([lastPathComponent isEqualToString:@"Localizable.strings"]) {
            [localizableStringsFiles addObject:fullPath];
        }
    }
    
    return [localizableStringsFiles copy];
}

+ (NSString *)removeCommentsInLocalizableStrings:(NSString *)localizableStrings
{
    // remove all multi line comments and single line comments
    NSMutableString *mutableLocalizableStrings = [localizableStrings mutableCopy];
    NSRange searchedRange = NSMakeRange(0, [mutableLocalizableStrings length]);
    NSString *pattern = @"(/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)";
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:nil];
    
    if (regex) {
        NSArray *matches = [regex matchesInString:localizableStrings options:0 range:searchedRange];
        NSInteger shift = 0;
        
        for (NSTextCheckingResult *match in matches) {
            NSRange range = match.range;
            
            range.location -= shift;
            
            [mutableLocalizableStrings replaceCharactersInRange:range withString:@""];
            
            shift += range.length;
        }
    }
    
    return [mutableLocalizableStrings copy];
}

+ (NSArray *)rawLocalizedStringEntriesFromLocalizableStrings:(NSString *)localizableStrings
{
    // get all entries in source string that match variations of "KEY" = "VALUE";
    NSRange searchedRange = NSMakeRange(0, [localizableStrings length]);
    NSString *pattern = @"\"(\\\\.|[^\"])*\"\\s*=\\s*\"(\\\\.|[^\"])*\";";
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:nil];
    NSMutableArray *rawEntries = [NSMutableArray array];
    
    if (regex) {
        NSArray *matches = [regex matchesInString:localizableStrings options:0 range:searchedRange];
        
        for (NSTextCheckingResult *match in matches) {
            NSString* matchText = [localizableStrings substringWithRange:[match range]];
            
            [rawEntries addObject:matchText];
        }
    }
    
    return [rawEntries copy];
}

+ (NSArray *)splitRawLocalizedStringEntry:(NSString *)localizedStringEntry
{
    // split found "KEY" = "VALUE"; strings in key and value strings
    NSRange searchedRange = NSMakeRange(0, [localizedStringEntry length]);
    NSString *pattern = @"\"(\\\\.|[^\"])*\"";
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern
                                                                           options:0
                                                                             error:nil];
    NSMutableArray *splitStrings = [NSMutableArray array];
    
    if (regex) {
        NSArray *matches = [regex matchesInString:localizedStringEntry options:0 range:searchedRange];
        NSCharacterSet *trimQuotesCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@"\""];
        
        for (NSTextCheckingResult *match in matches) {
            NSString* matchText = [localizedStringEntry substringWithRange:[match range]];
            
            matchText = [matchText stringByTrimmingCharactersInSet:trimQuotesCharacterSet];
            
            [splitStrings addObject:matchText];
        }
    }
    
    return [splitStrings copy];
}

+ (NSDictionary *)localizedStringsForLocalizableStringsFile:(NSString *)localizableStringsFile
{
    // collect all key/value string pairs in Localizable.strings file into a dictionary
    NSString *localizableStrings = [NSString stringWithContentsOfFile:localizableStringsFile encoding:NSUTF8StringEncoding error:nil];
    
    if (!localizableStrings) {
        localizableStrings = [NSString stringWithContentsOfFile:localizableStringsFile encoding:NSUTF16StringEncoding error:nil];
    }
    
    NSMutableDictionary *stringsDictionary = [NSMutableDictionary dictionary];
    
    if (localizableStrings) {
        localizableStrings = [self removeCommentsInLocalizableStrings:localizableStrings];
        
        NSArray *rawEntries = [self rawLocalizedStringEntriesFromLocalizableStrings:localizableStrings];
        
        for (NSString *rawEntry in rawEntries) {
            NSArray *splitEntry = [self splitRawLocalizedStringEntry:rawEntry];
            NSString *key = nil;
            NSString *value = @"";
            FCLocalizedStringEntry *entry = [[FCLocalizedStringEntry alloc] init];
            
            if (splitEntry.count > 0) {
                key = splitEntry[0];
            }
            
            if (splitEntry.count > 1) {
                value = splitEntry[1];
            }
            
            if (key) {
                entry.entryKey = key;
                entry.entryValue = value;
                entry.entryComment = nil;
                stringsDictionary[key] = entry;
            }
        }
    }
    
    return [stringsDictionary copy];
}


#pragma mark - Write Localized.strings file

+ (void)writeEntries:(NSDictionary *)entries toFile:(NSString *)file
{
    // sort comment groups keys
    NSArray *sortedCommentKeys = [[entries allKeys] sortedArrayUsingComparator:^NSComparisonResult(NSString *string1, NSString *string2) {
        return [[string1 lowercaseString] compare:[string2 lowercaseString]];
    }];
    
    NSMutableString *fileContent = [NSMutableString string];
    
    NSInteger commentCount = 0;
    
    // write sorted comment groups
    for (NSString *key in sortedCommentKeys) {
        [fileContent appendFormat:@"/* %@ */\n\n", key];
        
        NSArray *commentEntries = entries[key];
        NSInteger entryCount = 0;
        
        for (FCLocalizedStringEntry *entry in commentEntries) {
            entryCount++;
            
            if (entryCount != commentEntries.count) {
                [fileContent appendFormat:@"\"%@\" = \"%@\";\n\n", entry.entryKey, entry.entryValue];
            } else {
                [fileContent appendFormat:@"\"%@\" = \"%@\";", entry.entryKey, entry.entryValue];
            }
        }
        
        commentCount++;
        
        if (commentCount != sortedCommentKeys.count) {
            [fileContent appendString:@"\n\n\n"];
        }
    }
    
    [fileContent writeToFile:file atomically:YES encoding:NSUTF8StringEncoding error:nil];
}


#pragma mark - Genstrings for directory

+ (NSDictionary *)commentDictionaryForEntries:(NSArray *)entries
{
    // group string entries on comment
    NSMutableDictionary *commentDictionary = [NSMutableDictionary dictionary];
    
    for (FCLocalizedStringEntry *entry in entries) {
        NSMutableArray *commentEntries = commentDictionary[entry.entryComment];
        
        if (!commentEntries) {
            commentEntries = [NSMutableArray array];
            commentDictionary[entry.entryComment] = commentEntries;
        }
        
        [commentEntries addObject:entry];
    }
    
    // sort comment entries
    for (NSString *commentKey in [commentDictionary allKeys]) {
        NSMutableArray *commentEntries = commentDictionary[commentKey];
        
        [commentEntries sortUsingComparator:^NSComparisonResult(FCLocalizedStringEntry *entry1, FCLocalizedStringEntry *entry2) {
            return [[entry1.entryKey lowercaseString] compare:[entry2.entryKey lowercaseString]];
        }];
    }
    
    return [commentDictionary copy];
}

+ (void)genstringsForDirectory:(NSString *)directory
{
    // get collected strings from root directory .m, .xib and .storyboard files and compare
    // them with existing Localizable.strings files, we keep the values already in Localizable.strings files
    // for the collected keys found and then overwrite Localizable.strings files
    
    // get collected strings from root directory .m, .xib and .storyboard
    NSDictionary *collectedStrings = [self localizedStringsForDirectory:directory];
    
    // get all Localizable.strings paths
    NSArray *localizableStringsFiles = [self localizableStringsFilesForDirectory:directory];
    
    NSArray *collectedKeys = [collectedStrings allKeys];
    
    for (NSString *localizableStringsFile in localizableStringsFiles) {
        // get current strings in Localizable file
        NSDictionary *currentStrings = [self localizedStringsForLocalizableStringsFile:localizableStringsFile];
        NSMutableArray *entries = [NSMutableArray array];
        
        // set entry value to existing value if it is available
        for (NSString *key in collectedKeys) {
            FCLocalizedStringEntry *currentEntry = currentStrings[key];
            FCLocalizedStringEntry *collectedEntry = collectedStrings[key];
            
            if (currentEntry) {
                collectedEntry.entryValue = currentEntry.entryValue;
            } else {
                collectedEntry.entryValue = @"";
            }
            
            [entries addObject:collectedEntry];
        }
        
        // group strings based on comment
        NSDictionary *commentDictionary = [self commentDictionaryForEntries:entries];
        
        // overwrite existing strings file with updated strings 
        [self writeEntries:commentDictionary toFile:localizableStringsFile];
    }
}

@end
